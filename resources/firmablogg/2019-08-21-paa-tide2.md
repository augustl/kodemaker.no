:title Tid - hvor vanskelig kan det v√¶re? Del II   
:author christin
:published 2019-08-21
:tech [:java]

:blurb
I [del √©n](https://www.kodemaker.no/blogg/2019-08-paa-tide/) l√¶rte vi hvilke datatyper vi trenger i kode for √• h√•ndtere tid, men hvordan er det vi lagrer dem i en database? 

:body
I [del √©n](https://www.kodemaker.no/blogg/2019-08-paa-tide/) la jeg ut om hvor elendig, hvor tragisk, hvor latterlig, hvor ufattelig d√•rlig dagens kalender og tidssystem egentlig er.  Men det er lett √• klage kan du si. Er det egentlig s√• lett √• komme p√• gode alternativer?     

Selvsagt er det d√©t! Kjempelett! Med et s√• elendig utgangspunkt ville det jo v√¶re n√¶r fysisk umulig √• komme p√• noe verre.   

Det har ogs√• v√¶rt seri√∏se fors√∏k p√• √• endre kalenderen.  Det mest kjente er kanskje den [franske revolusjon√¶re kalenderen](https://no.wikipedia.org/wiki/Den_franske_revolusjonskalender). Den franske revolusjonen skulle v√¶re starten p√• en mer moderne tidsalder, og da m√•tte de naturligvis fikse kalendersystemet.  De valgte √• dele √•ret inn i 12 m√•neder, hver p√• 30 dager. (Samme lengde p√• hver m√•ned tenk!) Hver m√•ned var delt i tre uker med 10 dager i hver. 
Dette blir til sammen 360 dager, s√• da er det 5 dager igjen - 5 fest-dager! (6 dager hvert skudd√•r.)  Et d√∏gn bestod av 10 timer, hver p√• 100 minutter. 
Utrolig mye bedre enn det s√∏ppelet vi har av en kalender! Franskmennene brukte den i 12 √•r fra 1793 til 1805. Men s√• kom Napoleon og kastet hele greia. Skandale! 


Men det har v√¶rt flere fors√∏k og forslag siden. [Swatch time](https://en.wikipedia.org/wiki/Swatch_Internet_Time) er et interessant forslag. 

Og her er et veldig bra forslag presentert av Ove Gram Nipen:  
<blockquote class="twitter-tweet" data-conversation="none"><p lang="no" dir="ltr">13 mnd √° 28 dager + nytt√•rsaften + evt skudd√•rsdag gir god forutsigbarhet og kompatibilitet med dagens system, og vil v√¶re en klar forbedring.</p>&mdash; Ove Gram Nipen (@ovegram) <a href="https://twitter.com/ovegram/status/1161606816301834240?ref_src=twsrc%5Etfw">August 14, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-conversation="none"><p lang="no" dir="ltr">Legger du til at alle m√•neder starter p√• mandag, s√• blir utregning av ukedag p√• en gitt dato bare heltallsdivisjon. Nytt√•rsaften m√• da ikke v√¶re en ukedag. Dagen f√∏r nytt√•rsaften er s√∏ndag, dagen etter nytt√•rsaften er mandag. Skudd√•rsdag m√• ogs√• behandles slik.</p>&mdash; Ove Gram Nipen (@ovegram) <a href="https://twitter.com/ovegram/status/1161607135626747909?ref_src=twsrc%5Etfw">August 14, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-conversation="none"><p lang="no" dir="ltr">For √• forbedre systemet enda mer kan f√∏rste m√•ned v√¶re mars. Da vil september v√¶re den syvende m√•neden, oktober den √•ttende, osv. En bonus er at √•ret begynner med en v√•rm√•ned, og at vinteren holder seg innenfor ett √•r. Merk at det betyr at nytt√•rsaften er dagen etter 28. feb.</p>&mdash; Ove Gram Nipen (@ovegram) <a href="https://twitter.com/ovegram/status/1161607710858711042?ref_src=twsrc%5Etfw">August 14, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


##S√• hva er det vi venter p√•? 
>Jammen du kommer aldri til √• klare √• endre det! Det blir s√• mye jobb!   

Sier folk.  Denne innvendingen har man kommet med siden tidenes morgen om alle gode forslag. Fra kvinners stemmerett, 8-timers-arbeidsdag med 2 dagers helg, avvikling av slavedrift...  De sa nok det samme da folk begynte √• foresl√• metriske enheter.    

Er du ikke glad for at folk ikke h√∏rte p√• disse negative holdningene? Er du ikke glad for at det fantes folk med nok driv til √• gj√∏re verden til et bedre sted √• v√¶re? Tenk tilbake til tiden da metriske enheter ble innf√∏rt. Hva tenker du om de som kjempet imot? Tenker du "Wow, det var bra folk! Skulle √∏nske jeg var som dem!" Har ikke du lyst til √• v√¶re en av de som bidrar til at det blir bedre?  Folk har uansett bedre ting √• bruke tiden sin p√• enn √• dempe entusiasmen til de som sl√•r et slag for at ting blir bedre.  Som George Bernard Shaw s√• fint sa det:

>Those who say it cannot be done ‚Ä®should not interrupt those doing it.
 
Vi har klart √• komme oss vekk ifra teite m√•leenheter f√∏r. Vi klarer det igjen. 

##Start med √• bruke UTC
Men vi trenger ikke gj√∏re alt p√• en gang.  Vi kan for eksempel starte med √• bare bruke UTC istedenfor masse lokale tidssoner.  Hvis jeg bor i Tokyo, s√• vil arbeidstiden min kanskje v√¶re fra 23:00 til 07:00.  I New York starter arbeidsdagen 12:00 og slutter 20:00.  Det har jo ikke noe √• si hvilke tall som st√•r p√• klokka n√•r man st√•r opp om morgenen. Akkurat som at det ikke har noe √• si hva m√•neden heter for hvilken √•rstid man har.  Det at de bruker samme kalender som oss i New Zealand betyr ikke at de dermed er tvunget til √• ha sommer samtidig som oss.  De bader i desember og st√•r p√• ski i juli.  Og ingen tenker noe mer over det.  Akkurat slik kan vi ogs√• ha det med klokka.  Vi st√•r opp n√•r det blir lyst og legger oss n√•r det blir m√∏rkt helt uavhengig av hva det m√•tte st√• p√• klokka.  

##Lagring av tid
Men dette skulle jo egentlig v√¶re en praktisk guide til programmering med tid, s√• la meg komme til saken.  Forrige gang gikk jeg gjennom hvilke datatyper vi bruker i kode n√•r vi jobber med tid, men hva gj√∏r vi n√•r vi skal lagre dem? 
Her er det mange muligheter, med like mange overraskelser.
Vi kan jo begynne med PostgreSQL (gjerne uttalt "Post Grayskull").   
Postgres har kolonnetypene `timestamp` og `timestamp with time zone`. 
La oss leke litt med dem:    
 
```
CREATE TABLE test (withoutZone timestamp, withZone timestamp with time zone);
INSERT INTO test(withoutZone, withZone) 
VALUES(now(), now());
SELECT * from test;
```
Da f√•r vi for eksempel f√∏lgende:

```
withoutZone                | withZone
2019-07-31 13:19:52.013443 | 2019-07-31 13:19:52.013443 +02
```

For det f√∏rste ser vi at postgres har en formening om hva klokka er `now()`.  For det andre ser vi at tiden er lik i begge kolonner, men at vi har f√•tt med oss et UTC-offset i den andre kolonnen.       

Hva skjer s√• n√•r vi legger til verdier selv? For eksempel `2019-07-31T12:18:45.002+10` Alts√• rundt lunsjtider midt p√• vinteren i Australia. Vi legger den likes√•godt til i begge kolonner:

```
INSERT INTO test(withoutZone, withZone) 
VALUES('2019-07-31T12:18:45.002+10', '2019-07-31T12:18:45.002+10');

withoutZone             | withZone
2019-07-31 12:18:45.002 | 2019-07-31 04:18:45.002 +02
```
Hva har skjedd her? Vi ser at den f√∏rste kolonnen bevarer "local time" alts√• at det er rundt lunsjtider. Mens den andre kolonnen bevarer "instant". Men ikke i tidssonen man sendte inn. Dette eksemplet ble kj√∏rt p√• min maskin, s√• da har postgres 'oversatt' tiden til sin egen tidssone.

Men hva skjer n√•r vi bruker jdbc for √• legge til data?

```java
var time = Timestamp.from(
          ZonedDateTime.parse(
              "2018-07-31T12:18:45.002+10:00",
              ISO_ZONED_DATE_TIME)
              .toInstant());
try (
    var connection = dataSource.getConnection(); 
    var insert = connection.prepareStatement(
        "INSERT INTO event(withoutTZ, withTZ) " + 
        "VALUES(?, ?)", 
        RETURN_GENERATED_KEYS)) {
  insert.setTimestamp(1, time);
  insert.setTimestamp(2, time);
  insert.executeUpdate();
}
```

Det meste av Java-biblioteker som lar deg jobbe med databaser bruker jdbc i b√•nn. Og for √• lagre tid, bruker man datatypen `Timestamp`. Timestamp arver fra `java.util.Date` (üò±) og er i bunn og grunn en wrapper rundt en long.  
S√• hva er det som faktisk ender opp i basen her?

```
withoutZone              | withZone
2019-07-30 22:18:45.002  | 2019-07-31 04:18:45.002 +02
```
H√¶?  
Hva har skjedd her? 
N√• endte vi opp med 22:18 kvelden f√∏r i den f√∏rste kolonnen og samme verdi som sist i den andre kolonnen. Hva i alle dager?  

Det var fordi et sted i koden f√∏r denne snutten ble kj√∏rt s√• sto det f√∏lgende: 

```java
TimeZone.setDefault(TimeZone.getTimeZone("America/New_York"));
```

Dette er viktig. Databasen lagrer tid som et tall. Java lagrer ogs√• tid som et tall. Men n√•r Java sender tid til databasen, s√• blir dette tallet representert som en tekst-streng.  Og for √• generere denne tekst-strengen trenger Java en tidssone. Med mindre du angir en i `setTimestamp()`-metoden (se under) s√• bruker den det som m√•tte v√¶re default. Pass p√• √• vite hva denne defaulten er. Helst b√∏r den v√¶re UTC.  Dersom du har en prosess med UTC som default som skriver til databasen. Og en annen prosess som leser fra databasen som har lokal tidssone som default, s√• vil du f√• helt feil tid i koden. 

```java
insert.setTimestamp(1, time, Calendar.getInstance(getTimeZone(time.getZone())));
``` 

Dersom du m√• lagre tid i forskjellige tidssoner i databasen er du helt n√∏dt til √• lagre selve tidssone-id'en i en separat kolonne. S√• kan du opprette en ZonedDateTime ved √• sl√• sammen verdien fra en timestamp kolonne og fra tidssone-kolonnen. 
B√•de `java.time` og `NodaTime` har gode m√•ter √• oversette tid fra en tidssone til en annen.  
I Java kan man lese ut en timestamp fra databasen som UTC-tidspunkt, ogs√• konvertere den til lokal sone ved √• enten beholde den "lokale tiden": 

```java
ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneOffset.UTC).withZoneSameLocal(ZoneId.of("Europe/Oslo"))
```
Eller ved √• beholde samme instant.

```java
ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneOffset.UTC).withZoneSameInstant(ZoneId.of("Europe/Oslo"))
```  
N√•r man gj√∏r slike konverteringer er det ogs√• greit √• tenke over hva man gj√∏r hvis tidspunktet som blir oversatt inntreffer i overagangen mellom sommer- og vintertid.
Alts√• dersom tidspunktet i UTC er "2019.10.27T02:30:00Z" og vi √∏nsker √• oversette dette til norsk tid, med samme "local time", s√• m√• vi jo ta stilling til HVILKEN 02:30 er det det er snakk om.
Dette kan gj√∏res med f√∏lgende metoder:

```java
ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneOffset.UTC)
    .withZoneSameLocal(ZoneId.of("Europe/Oslo"))
    .withEarlierOffsetAtOverlap();
```
Og 

```java
ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneOffset.UTC)
    .withZoneSameLocal(ZoneId.of("Europe/Oslo"))
    .withLaterOffsetAtOverlap();
```
Av en eller annen grunn har ikke Java-metoder for √• h√•ndtere tilsvarende situasjoner i overgang til sommertid. Konverterer man tid "02:30" i d√∏gnet med overgang til sommertid, s√• vil det bli oversatt til "03:30". Dersom du trenger at den velger timen f√∏r, kan du for eksempel skrive f√∏lgende funksjon:

```java
public Instant toEarliestPossibleInstant(LocalDateTime localDateTime, ZoneId zone) {
  var transition = zone.getRules().getTransition(localDateTime);
  var gapDuration = Optional.ofNullable(transition)
      .filter(tr -> tr.isGap())
      .map(tr -> tr.getDuration())
      .orElse(Duration.ofNanos(0));

  return ZonedDateTime.of(localDateTime, zone)
      .withEarlierOffsetAtOverlap()
      .minus(gapDuration).toInstant();
}
```  
I NodaTime er man n√∏dt til √• ta stilling til begge disse scenariene hver gang man oversetter til en tidssone, ved √• bruke `Resolvers`:

```
local.InZone(
   zone, 
   Resolvers.CreateMappingResolver(
       Resolvers.ReturnEarlier, 
       Resolvers.ReturnEndOfIntervalBefore))
```

For √• oppsummere, s√• er det ofte best √• lagre tid i UTC i databasen, for s√• √• oversette til lokal tidssone ved behov i koden.

##SQLServer

Hver database har sine egne kolonne-typer med sine egne s√¶rheter.  Det er viktig √• bli kjent med dem og v√¶re klar over eventuelle begrensninger.  Den mest overraskende jeg har v√¶rt borti er SQLServer sin kolonnetype for tid `DateTime`.  Denne har en presisjon p√• 3ms. All tid du lagrer i en `DateTime`-kolonne blir rundet opp eller ned til n√¶rmeste 3ms!    
Verdien `2019-01-01T23:59:59.999` blir lagret som `2019-01-02 00:00:00.000`    
alts√• DAGEN ETTERP√Ö!   

`2019-01-01T23:59:59.995`,     
`2019-01-01T23:59:59.996`,     
`2019-01-01T23:59:59.997`,      
`2019-01-01T23:59:59.998`     
ender alle opp som `2019-01-01T23:59:59.997`.    

`2019-01-01T23:59:59.992`,    
`2019-01-01T23:59:59.993`,    
`2019-01-01T23:59:59.994`     
blir til `2019-01-01T23:59:59.993`.    

`2019-01-01T23:59:59.990` og `2019-01-01T23:59:59.991` blir til `2019-01-01T23:59:59.990`.    

Dette er mildt sagt uventet oppf√∏rsel for de fleste! Microsoft har √•penbart ogs√• angret litt p√• denne implementasjonen og har siden innf√∏rt flere kolonnetyper, for eksempel `DateTime2` som lagrer det tidspunktet du faktisk sender ned.  Bruk den! 

##Test mot en reell database
Alle databaser har som nevnt allerede sine s√¶rheter, s√• det er viktig √• ha gode automatiske tester som kj√∏rer mot en database av den typen du skal bruke i prod.  Du trenger ikke la alle testene g√• mot en reell database, men du b√∏r absolutt ha en god del. Hvordan `null` verdier blir h√•ndtert, hvordan tid blir h√•ndtert, det er masse rom for overraskelser n√•r man skal lagre verdier og hente dem ut igjen. Det er best √• oppdage disse i test.   
Jeg har gode erfaringer med √• kj√∏re opp en prod-lik database for testene - for eksempel [OpenTable Embedded PostgreSQL](https://github.com/opentable/otj-pg-embedded). For SQLServer kan man f.eks kj√∏re opp en [docker-container](https://hub.docker.com/_/microsoft-mssql-server). N√•r basen er oppe, kj√∏rer man samme [Flyway](https://flywaydb.org) migreringsskript som i prod, s√• har du en lokal database √• teste mot. Videre kan man lage en TestRunner som starter en transaksjon f√∏r testen og ruller den tilbake igjen etter testen, slik at dataene testen bruker ikke ender opp med √• affektere andre tester, noe som gj√∏r at testene kan kj√∏res i parallel. 
Hvordan dette b√∏r/kan gj√∏res vil jo avhenge av hvordan database-oppsettet til prosjektet er.  Jeg kan kanskje skrive mer om et eksempel p√• et slikt oppsett en annen gang.

##Test med `now()`
Ofte er det n√•tidspunktet man √∏nsker √• lagre, eller sette p√• et felt i koden.  

```java
public Event insertNewEvent(String description) {
  queryRunner.insert("INSERT INTO event(?, ?", Timestamp.from(Instant.now()), description);
  ...
}
``` 
Hvordan skal vi teste at denne metoden ender opp med √• sette riktig tid p√• det som lagres? 

```java
@Test
public void should_store_correct_time() {
   assertThat(insertNewEvent("test").getTime()).isEqualTo(????);
}
```
Her kan man bruke triks som √• mocke ut selve klokka.  Istedenfor √• skrive `Instant.now()`, kan man skrive `Instant.now(clock)`. Hvor clock kan v√¶re `Clock.systemUTC()` i prod, men `Clock.fixed(instant, zone)` i testen for eksempel.   
Jeg anbefaler √• IKKE gj√∏re dette.  Det blir mer kompleksitet, mer kode, du kommer til √• ende med √• skrive dine egne klokke-implementasjoner, eller mocke ut klokka.. masse st√∏y.    
Det er mye bedre √• heller la `now` v√¶re en input-parameter i koden.  

```java
public Event insertNewEvent(Instant now, String description) {
  queryRunner.insert("INSERT INTO event(?, ?", Timestamp.from(now), description);
  ...
}
```
I prod kalles denne metoden med Instant.now() som parameter, mens i testen din sender du inn det tidspunktet du kommer til √• kj√∏re assert p√• etterp√•.   
INGEN ekstra kompleksitet   
INGEN ekstra kode.   
MYE enklere √• teste. 


Det f√•r v√¶re nok for denne gang, takk for meg, og lykke til!
